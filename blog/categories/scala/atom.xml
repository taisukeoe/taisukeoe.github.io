<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Scala | OE_uia Tech Blog]]></title>
  <link href="http://taisukeoe.github.io/blog/categories/scala/atom.xml" rel="self"/>
  <link href="http://taisukeoe.github.io/"/>
  <updated>2017-03-05T17:47:02+09:00</updated>
  <id>http://taisukeoe.github.io/</id>
  <author>
    <name><![CDATA[Taisuke Oe]]></name>
    <email><![CDATA[oeuia.t@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[ScalaMatsuriの初社員採用プロジェクト これまでの運営の失敗と成功の歴史 ~ScalaMatsuri 2017を振り返って~]]></title>
    <link href="http://taisukeoe.github.io/blog/2017/03/05/scalamatsuri-employee/"/>
    <updated>2017-03-05T17:23:56+09:00</updated>
    <id>http://taisukeoe.github.io/blog/2017/03/05/scalamatsuri-employee</id>
    <content type="html"><![CDATA[<p>ScalaMatsuriにご参加いただいた皆さん、ありがとうございました。</p>

<p>ScalaMatsuri座長の麻植(<a href="https://twitter.com/oe_uia">@OE_uia</a>)です。</p>

<p>一般販売のチケット販売＋スポンサー招待枠＋関係者もろもろを合わせまして、総勢600名程度の方にご参加いただきました(実数はまだ集計中です)。
参加、登壇、協賛、そしてスタッフとして、皆さんがScalaMatsuriという神輿を担いでくださったお陰で、今年も盛況のうちに幕を閉じることが出来ました。</p>

<h2>国際化の進むScalaMatsuri</h2>

<p><a href="http://taisukeoe.github.io/blog/2016/02/05/internationalize-scalamatsuri/">昨年の振り返りブログ</a>では言及したScalaMatsuriの国際化はさらに進み、フィリピンのパーペチュアル・ヘルプ大学から30人ほどの団体参加者と、Scala Taiwanの団体参加者、そしてその他の国からの参加者も増えました。</p>

<p><a href="https://twitter.com/ktosopl/status/836537725926912001">https://twitter.com/ktosopl/status/836537725926912001</a>&#8220;>https://twitter.com/ktosopl/status/836537725926912001&#8221;>https://twitter.com/ktosopl/status/836537725926912001</a></a></p>

<p>また、それ以上に参加者全体の意識の変化も見て取れました。去年はまだまだ日本ローカルの参加者と、海外からの参加者が別れて交流しがちだったのですが、2日目夜の有志による寿司ディナーでは入り混じり、国際カンファレンスらしい交流がそこかしこで繰り広げられるようになりました。</p>

<p><a href="https://twitter.com/rabbitonweb/status/835830465181278208">https://twitter.com/rabbitonweb/status/835830465181278208</a>&#8220;>https://twitter.com/rabbitonweb/status/835830465181278208&#8221;>https://twitter.com/rabbitonweb/status/835830465181278208</a></a></p>

<p>とまあ、国際化は引き続き順調に進んでいるので敢えて言うほどのこともないですし、今回の振り返りブログはScalaMatsuri運営の内情と、今年度の構造改革の中身についてお話します。</p>

<p>なお、お気づきの方も多いかと思いますが、タイトルはかとじゅんさんの今回のScalaMatsuriセッションタイトルのパロディです。</p>

<h1>三行 / TL;DR</h1>

<ul>
<li>ScalaMatsuriはボランティア運営のコミュニティカンファレンスだが、大きくなるにつれスタッフの負担が重くなり継続の危機に陥っていた</li>
<li>ScalaMatsuriは今年度、初めて社員を雇うなどの構造改革を行った</li>
<li>結果、スタッフの事務負担を大きく緩和し、持続可能な運営体制と、より重要な企画に集中的に時間を使える仕組みを作ることができた。</li>
</ul>


<!--MORE-->


<h2>持続可能な仕組みへのリプレイス</h2>

<p>ScalaMatsuriの各セッションも好評で、その中でも非常に注目を集めたセッションとして、<a href="https://twitter.com/j5ik2o">かとじゅん</a>さんによる「ChatWorkのScala採用プロダクト “Falcon” リリースまでの失敗と成功の歴史」というものがありました。</p>

<p>ユーザーににさほどの意識をさせることなく、このままでは破綻が見えていたレガシーシステムから、スケーラブルなシステムへの移行を成功させた、日本のScala業界でもエポックメイキングなものでした。当日は大盛況でしたし、来れなかった方も、(録画はありませんが)スライドは公開される予定ですのでお楽しみに。</p>

<p>さて実はScalaMatsuri準備委員会、そしてその母体となる一般社団法人Japan Scala Associationも、同じように皆さんから見えないところで、このままでは破綻が見えていたシステムから、スケーラブルとは言わない間でも、十分持続可能なシステムへ移行をしていました。</p>

<p>それは、<strong>コミュニティカンファレンスとしてボランティア有志で運営していたところに、創業以来初となる従業員を雇い入れたことです</strong> 。</p>

<p>コミュニティカンファレンスと商業カンファレンスの最大の違いは、スタッフが皆他の仕事をしながら、ボランティアベースで運営している点でしょう。
コミュニティカンファレンスはコミュニティの中の人がつくり上げるため、特定の企業に依存せず、より公平で民意を取り入れやすいというメリットがある一方で、運営スタッフは他の仕事する傍らに準備をするため、工数が確保しにくいというデメリットがあります。実際のところ、ScalaMatsuriが大きくなるにつれ、ボランティアベースでの運営は年々厳しさを増していました。</p>

<p>例えば、<strong>昨年は私の場合開催１ヶ月前は殆どの時間がMatsuriに吸い取られる状態で、他の仕事は週1~2程度しか出来ませんでした</strong> し、
他のスタッフもそこまでひどくないにはしろ、かなりの疲弊感が漂っていました。</p>

<p>特にメール対応業務は平日昼間に発生することが多く、他の仕事を並行して行っているスタッフは対応の限界がとうに訪れていました。
どのくらいマズイ状態だったかといえば、メール対応を行っていたスタッフは、ほぼ例外なく燃え尽きて、次年度のスタッフ参加を避ける、という状態でした。</p>

<p>コミュニティカンファレンスでは、どこも程度の大小は有れど、共通の問題として抱えてることだと思います。例えば、一昨年のフランスの<a href="http://scala.io/">Scala.IO</a>カンファレンスでも、リードボランティアの時間が取れない等の理由により、開催自体が突然中止されました。ScalaMatsuriも実際、昨年までは僕を含めた数人が単一障害点/Single Point of Failureでしたので、同じことがいつ起きても不思議ではありませんでした。</p>

<p>そんな状態だったので、昨年のScalaMatsuri振り返りブログを書いた後、竹添さんとこんな会話をしたことを覚えています。</p>

<p><a href="https://twitter.com/takezoen/status/695891610555420672">https://twitter.com/takezoen/status/695891610555420672</a>&#8220;>https://twitter.com/takezoen/status/695891610555420672&#8221;>https://twitter.com/takezoen/status/695891610555420672</a></a></p>

<p><a href="https://twitter.com/OE_uia/status/696361023410835456">https://twitter.com/OE_uia/status/696361023410835456</a>&#8220;>https://twitter.com/OE_uia/status/696361023410835456&#8221;>https://twitter.com/OE_uia/status/696361023410835456</a></a></p>

<p>時は前後しますがこの半年ほど前、私が信頼を寄せている友人である高橋さんが、結婚したので家事と両立できる仕事を事務職を探している、という話を聞いた時、ScalaMatsuriの事務仕事はほぼ100%リモートワークだけど、興味はないかと申し出ました。</p>

<p>そのときから、給与体系、勤務体系、仕事内容などなどの説明や調整をしながら、およそ１年弱の時を経て、今年度のScalaMatsuri準備委員会の事務サポートとして入ってもらうことになったのです。</p>

<h2>ScalaMatsuri初の社員が入って</h2>

<p><strong>彼女が入ったことで、ScalaMatsuriの事務は驚くほどうまく回るようになりました。</strong></p>

<p>平日昼間に発生しがちなメール対応業務は、即座に返せることが多くなりました。
また日中Slackやissueを見て回ってもらえることで、ボールの取りこぼしが起きにくくなりました。
その他でも当初は予定していなかったような細々とした仕事、例えば翻訳後テキストをスライドに字幕としてつけるなど、定形作業が発生しがちな翻訳チームのサポートなど、多岐に渡って仕事を見つけて動いてくれました。
個人的には、僕の時間を取られていた経理業務の大半を彼女に渡せたことで、より全体を見るという仕事に時間を割くことができるようになりました。</p>

<p>結果として、特定の準備委員に負担がしわ寄せされるという事態も、相当に軽減されました。</p>

<h3>今回のスキームが上手くいった理由</h3>

<p>振り返って考えてみると、このスキームが上手く行った理由は幾つかあります。</p>

<h4>非属人的で重要だったもの</h4>

<ul>
<li>スタッフの余暇の時間で業務を行っていたため、殆どの仕事に使うツール群はリモート前提で選定・導入が済んでいる</li>
<li><strong>(ほぼ)100%リモートワークの事務仕事はとても希少で、既婚者に需要がある。</strong></li>
<li>職場の雰囲気が良い（僕はもう慣れすぎて分からないけど、本当に言われる）。

<ul>
<li>理由を推察するに、皆楽しいからスタッフ仕事をしていて、生活のために嫌々仕事してる人がいない、というのが大きい。</li>
<li>また人事・職務は流動的なので、自分がモチベーションを感じる役割で仕事を出来る</li>
<li>どうしても合わなければ抜けることも簡単に出来るので、例えば仮に致命的にウマが合わない人同士が居ても、長期間に渡って一緒に働かされる、ということがない。</li>
<li>今年度からスタッフとして入ってくれた<a href="https://twitter.com/yutayokoi0117">@yutayokoi</a>さんが「大人のサークル活動」と表現しているけど、まさにその通りの雰囲気だと思う。</li>
</ul>
</li>
</ul>


<h4>属人的で、プラスに働いたもの</h4>

<ul>
<li>元々友人関係があったので、お互い質問しやすく、また頼みやすかった。(コミュニケーションコストが最初から小さかった)

<ul>
<li>もっといえば、常に顔を合わせて働いているわけではないので、困った時にチャットで気軽に聞いてもらえるかどうかが、業務を円滑に進める上で非常に重要。</li>
</ul>
</li>
<li>彼女にSE経験があり、そこまでCUIツールやWebサービスへの抵抗感がなかった。</li>
<li>彼女に経理経験があった。</li>
</ul>


<p>このように、実は今回が特殊ケースというより、<strong>コミュニティカンファレンスの人手需要と、リモートワークの事務仕事に対する需要はとても相性が良い</strong> ものだと思います。事務系業務の重さに苦しんでいるコミュニティカンファレンスの運営者は、社員ないしは業務委託という形で、お仕事で事務をしてくれる人を引き入れることをぜひ検討してみてください。</p>

<p>とはいえ、ノウハウが全くない状態でいきなり人を入れるのはハードルが高いと思いますので、仕事内容・労働条件・その他もろもろについて、出来るだけ詳細に書いていこうと思います。</p>

<h3>仕事内容</h3>

<p>お願いする業務は、業務への慣れや季節性をふまえて、以下のように徐々に増えていきました。</p>

<h4>2016年7月頃から</h4>

<ul>
<li>経理

<ul>
<li>経費精算</li>
<li>請求書管理</li>
<li>仕分け</li>
</ul>
</li>
</ul>


<h4>2016年8月頃から</h4>

<ul>
<li>アカウント管理

<ul>
<li>Google Apps</li>
<li>Slack</li>
<li>GitHub</li>
</ul>
</li>
<li>準備委員会ミーティングの議事録作成と、Next Stepsのissue化</li>
<li>準備委員会ミーティングのイベントページ管理</li>
</ul>


<h4>2016年9月頃から</h4>

<ul>
<li>スポンサー対応

<ul>
<li>メール対応</li>
<li>スポンサー特典のステータス管理</li>
<li>Webサイトの更新(ロゴ、求人情報等)</li>
<li>各種関連ドキュメント作成</li>
</ul>
</li>
</ul>


<h4>2016年10月頃から</h4>

<ul>
<li>翻訳チームサポート

<ul>
<li>CFPの応募に対する、各種作業フローのサポート</li>
<li>Webサイトへの反映</li>
</ul>
</li>
</ul>


<h4>2016年11月頃から</h4>

<ul>
<li>企業法務

<ul>
<li>登記事項の変更の申請など</li>
</ul>
</li>
<li>様々なチームの落ち穂拾い、サポート</li>
</ul>


<h4>2017年1月頃から</h4>

<ul>
<li>Twitterの@scala_jpアカウントの運用</li>
<li>翻訳チームサポート

<ul>
<li>スライドへの字幕付け</li>
</ul>
</li>
</ul>


<p>元々はスポンサー対応や経理をしてもらえれば十分、と思っていました。
ですが、彼女はとても意欲を持って取り組んでくれて、上記の通り様々な業務に取り組んでもらっています。</p>

<h3>労働条件</h3>

<p><strong>2016年の7月から12月までは業務委託、2017年1月からは従業員として働いていただいてます</strong>。</p>

<p>2016年はどのみち彼女の確定申告が必要だったということ、並びに従業員を雇うということに対し最初は何も知見がなく抵抗があったこと、またお互いのお試し期間は少し欲しいよね、というもろもろ事情もありまして、業務委託にさせてもらっていました。
実際のところ、このスキームは全く新しい試みだったので、果たして上手くいくのかどうかという不安も正直なところありました。
ですが蓋をあけてみると、準備委員会のスタッフからも、彼女からも大好評で、ぜひともお互い一緒に仕事を続けたいということになりまして、従業員になっていただきました。</p>

<p>余談ですが、これが僕の人生初の雇用経験だったので、給与や雇用保険の計算から各種書類の作成・ハローワークへの届け出まで、高橋さんと一緒に色々と右往左往しながら対応したのは良い思い出ですｗ</p>

<p>労働契約としては裁量労働制で、通年で平均すると、およそフルタイムの半分程度の時間を割いてもらっている計算です。
とはいえ、カンファレンスは季節性のある仕事なので、カンファレンス開催前後はとても忙しく、逆に終わって残務整理が落ち着いた後は、非常に仕事が少なくなります。</p>

<p>土日は基本的に休みで、ミーティングは月1の準備委員会定例ミーティングのみに必ず出てもらい、そのぶん他の平日に代休を取ってもらうような運用です。
その他、彼女から休暇の申請があったときには、僕や他のスタッフがサポートに入るなどし、適宜調整しています。</p>

<p>それ以外のミーティングとしては、全体のもくもく会を月１程度でやったり、必要に応じて僕と彼女で毎週1回のぷちもくもく会を設定して引き継ぎ含め、業務の相談等を一緒にやっていました。</p>

<p>なお、給与については、彼女が既婚であり扶養に入っていることをふまえ、カンファレンスの現予算でも十分賄うことができる金額で調整し、設定しています。</p>

<h3>リモートワークを助ける仕組み</h3>

<p>100%事務仕事をリモートワーク可にする仕組みにもひと工夫ありました。</p>

<p>経理業務など、書類を扱う仕事ではリモートワーク化が難しいと思います。というのも、書類で請求書等などの管理が必要な会社は多いですし、規模感・業界も様々な協賛企業との間で業務が発生する弊社では、完全にペーパーレスにすることは困難です。</p>

<p>Japan Scala Associationでは、今年度から <strong>郵送物転送サービスのあるバーチャルオフィスを登記先に変更することで、住所に一枚抽象レイヤを追加</strong> しました。
これによって彼女の住所を晒すことなく、請求書などの郵送物を彼女に直接受け取ってもらい、経理処理を進めてもらえる体制が出来ました。</p>

<p>また、業務連絡はSlack、タスク管理はGitHub issues、ファイル管理はGitHubとGoogle Drive、各種提出物はGoogle Form、スポンサー関連の各種管理はGoogle Spreadsheet、各種自動化はZapierと、リモートワークでもそのまま使えるツール群は既に採用し運用実績が有りました。</p>

<p>また、スポンサーのWebロゴ掲載のサイズ変更等の編集にはImage Magick CLIを使用しています。</p>

<p>もちろん、非エンジニアにgit、Zapier、Image Magickといったツールを使いこなしてもらうのは簡単なことではありませんが、
gitの場合はSource TreeなどのGUIツールも有りますし、特に高橋さんの場合は意欲高く学んでもらえました。</p>

<p>最初に丁寧に教えて、あと困った時の質問への回答を何度かした程度で、実際に彼女は今ではGitHubにも慣れIssue管理をしたりPullRequestを送れるようになったり、またZapierでGoogle FormとSlackの連携の自動化をしたり、その他ツール周りにも慣れてもらうまでになりました。</p>

<h3>権限管理</h3>

<p>ここは様子をみながら調整する必要が有りますが、基本的にビジネス上の決定は座長(僕)やチームリーダーが行い、経理業務も実際の振込作業だけは座長が行っています。</p>

<p>また、出来るだけドキュメントやWikiなどに決定事項を残すことで、彼女が誰かに聞かずとも答えられる・判断できる範囲を広げることが重要です。</p>

<p>このようにして、無理のない形で徐々に仕事の移管ができ、ようやく継続可能で、かつコミュニティ色を失わないScalaMatsuri運営体制を作り上げることができました。</p>

<h2>その他の試み</h2>

<h3>ネイティブ英語スピーカーによるチェック体制導入</h3>

<p>また実は、彼女以外にも、スタッフである<a href="https://twitter.com/eed3si9n">Eugene Yokota</a>さんの友人のSandyに、
<strong>英語ドキュメントのネイティブチェックについて、リモートベースでお仕事としてお願いするという試み</strong> をスタートしました。ここについては、Yokotaさんにスキームのリードをしていただいています。この仕組みも非常に上手くワークしました。
(なお、Sandyについては、従業員ではなく、飽くまで業務委託として発注しています)</p>

<h3>耐障害性を高めるマニュアル化</h3>

<p>まだまだ進行中ですが、今まで属人性の高かった各種業務のドキュメント化、マニュアル化を今年度から様々な面で進め始めました。ここについては <a href="https://twitter.com/noriakihoriuchi">@noriakihoriuchi</a> さんや、 <a href="https://twitter.com/takezoux2">@takezoux2</a> さんにリードしていただいたりしています。</p>

<p>これにより、万が一誰かが動けなくなっても、他の人がバックアップしやすい体制を強化していきたいと思っています。</p>

<h1>総括</h1>

<p>振り返ってみると、<strong>より持続可能で耐障害性の高いスキームを作って、リクルーティング・導入・運用をして成功を収めた</strong> ことが、僕の座長としての初年度の、ちょっと胸の張れる成果なのかなと思っています。</p>

<p>これによってスタッフの事務作業に割かなければいけない時間が減り「どうやってScalaMatsuriを改善していくか」という本質的な問題について考える時間がとれるようになってきました。今まではリソース的制約により、やりたいけど出来なかったことが幾つも有りましたが、今後はそういったことにも取り組める体制ができたのではないかと思っています。</p>

<p>このブログを読んで、<strong>「次年度にScalaMatsuriスタッフとして参加してみたい！」</strong> という気になった方がいましたら、<strong>3月下旬〜4月頭に都内で開催を予定している、ScalaMatsuri2017スタッフ打ち上げにぜひご参加ください</strong>。実費分の参加費を頂戴しますが、今年度スタッフだけでなく、次年度のスタッフ参加を検討している方もご参加いただけますので、雰囲気や内情など色々見聞きしてもらえる機会になると思います。詳細は決まり次第、<a href="https://twitter.com/oe_uia">@OE_uia</a>のアカウントで告知します。</p>

<p>また <strong>この件や、その他ScalaMatsuriの運営について詳しく話が聞きたいカンファレンス運営者がいたら、お気軽に<a href="https://twitter.com/oe_uia">@OE_uia</a>までメンションを飛ばして下さい。</strong> 僕がPyConやその他先輩カンファレンスのみなさんにしていただいたように、次の世代へ知見を伝えていきたいと思っています。</p>

<p>最後になりますが、 <strong>今年度大活躍してくれた高橋さん、本当にありがとうございました。</strong> 今後共よろしくお願いします！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Scala関西サミットでAndroid Akkaについて喋ってきた話]]></title>
    <link href="http://taisukeoe.github.io/blog/2016/12/03/scala-kansai/"/>
    <updated>2016-12-03T23:26:02+09:00</updated>
    <id>http://taisukeoe.github.io/blog/2016/12/03/scala-kansai</id>
    <content type="html"><![CDATA[<p>さて、<a href="http://qiita.com/advent-calendar/2016/scala">2016年Scalaアドベントカレンダー@Qiita</a> 3日目です。</p>

<p>何を書こうかと考えていたら、そもそも10/8に開催されたScala関西サミットの話をブログに書いてないことに気づきました。</p>

<p>なので今回はそのことを紹介しつつ、色々補足できたらと思っています。</p>

<p>その前に。</p>

<h1><a href="http://summit.scala-kansai.org/">Scala関西サミット</a>の感想</h1>

<p>時期を逸した感じがしますが(きの子さんすいません…)、去年にも増して楽しかったです！</p>

<p>(結果的に)タイムテーブルの組み方が非常によくできていて、特にB会場のトラックがActorモデルの解説から、Akka-Stream、と続いていき、最後にAkka Clusterの闇の話が入る、という最高の流れでした。</p>

<p>そして日本各地からだけでなく、台湾からの参加者もいらっしゃるなど、多様性という意味でも大きくグレードアップしていました。</p>

<p>これが無料イベントって… 運営のことが非常に心配になりますので、お金払いますから今後もぜひ続けて下さい、という気持ちです。</p>

<p></br></p>

<p><a href="http://2017.scalamatsuri.org/">ScalaMatsuri</a>も負けてられません！</p>

<p>というわけで、ただいまセッション投票の集計＆選考＆タイムテーブル準備などの真っ最中でございます。</p>

<p>近々、遅くとも年内にはまとまった情報を出せると思いますので、しばしお待ちくださいませ。</p>

<p>僕の主観ですが、今までにも増して豪華で面白いトークの集まる、素晴らしい２日間になると思います。</p>

<p>さて、本題。</p>

<h1><a href="http://summit.scala-kansai.org/">Scala関西サミット</a>のスライド</h1>

<p><a href="http://www.slideshare.net/TaisukeOe/real-world-android-akka">http://www.slideshare.net/TaisukeOe/real-world-android-akka</a>&#8220;>http://www.slideshare.net/TaisukeOe/real-world-android-akka&#8221;>http://www.slideshare.net/TaisukeOe/real-world-android-akka</a></a></p>

<p>このトークではActorモデルの解説と、Actorモデルがなぜ<a href="">BONX</a>というVoIPアプリにフィットしたのか、という話をさせていただきました。</p>

<p>ただ、あまりAkkaのカスタマイズ性がVoIPのチューニングにどう役立つのか、という話は出来ずじまいでした。
今回はそこにフォーカスをあてます。</p>

<h1>非機能要件の改善</h1>

<p>VoIPアプリの場合、機能要件の実装・テストより、非機能要件の改善に時間を使います。
具体的には音質と遅延の改善です。</p>

<h2>音質の改善</h2>

<p>Actorモデルで設計されたVoIPモジュールにおいて何が一番音質の劣化原因になるかといえば、フレーム間で発生した遅延や、フレームの欠落です。</p>

<p>あるフレームが再生されてから、次のフレームが再生されるまでに間に大きく遅延すると、そこで波形が途切れること（非線形）になりますので聴感上ブツッというノイズに感じます。</p>

<p>同様にして、フレームの欠落が起きると、やはり前後のフレームが非連続になりますのでノイズに感じます。</p>

<p>大雑把に言えば、遅延の改善が音質の改善に繋がります。</p>

<h2>遅延の改善</h2>

<p>では、遅延をどのように改善したら良いでしょう。</p>

<p>安定している条件では、Akkaというより、個々の計算量を減らすなどモジュールごとのチューニングが必要となることが多いです。</p>

<p>しかし音声ストリーム処理の、しかもグループ通話など負荷が時間とともに変わりうる場合だと、Actorシステムにボトルネックが生じることが往々にしてあります。</p>

<p>まず測定・監視して詰まりやすいhotspotになる場所を探し出し、その後で負荷を分散・解消する方策を考え試行錯誤する必要があります。</p>

<p>解決策は十分にdispatcherの並列度を上げる必要があるときもあれば、局所的にActorを並列化するべきなケース、throughtputなどのパラメーターが重要になるケースなど様々です。</p>

<p>Akkaではこういた実行モデルのチューニングの大部分を、confファイルで簡便に変更出来る点で優れています。</p>

<p>また、Mailboxのサイズを適切に設定することも重要です。</p>

<p>小さすぎて溢れるとフレームの欠落になりますし、かといって大きすぎると遅延の解消に時間がかかります。</p>

<p>音声ストリーム処理の改善、とても難しいけど、チューニングがユーザー体験に直結するのはなかなかレアなので面白いです。</p>

<p>そんなAkkaのチューニングをやりたい方、今Androidエンジニアを絶賛募集中ですので、よかったら<a href="https://www.wantedly.com/projects/76119">こちら</a>からどうぞ。</p>

<p>それでは。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Scala標準のPromiseがAndroidで便利だという話]]></title>
    <link href="http://taisukeoe.github.io/blog/2015/12/15/scala-promise-sample-for-android/"/>
    <updated>2015-12-15T23:10:05+09:00</updated>
    <id>http://taisukeoe.github.io/blog/2015/12/15/scala-promise-sample-for-android</id>
    <content type="html"><![CDATA[<p>この記事は、<a href="http://www.adventar.org/calendars/904">Scala Advent Calendar</a> 13日目です。</p>

<p>今日は<code>scala.concurrent.Promise</code>の話をします。</p>

<p><a href="http://www.scala-lang.org/api/current/index.html#scala.concurrent.Promise">Promise - Scala Standard Library 2.11.7 - scala.concurrent.Promise</a></p>

<p>そもそも<code>Promise</code>って使いどころがわかりにくいですよね。他人のコードで使ってるの、ほとんど見たことがありません。</p>

<p>公式ドキュメントではProducer-Consumerパターンでの使い方を解説していますが、現実にこの使い方が必要になるケースってあまり遭遇せず、たいていの場合はFuture同士のflatMapによる合成で事足りてしまうと思います。</p>

<p><a href="http://docs.scala-lang.org/ja/overviews/core/futures.html">Future と Promise - Scala Documentation</a></p>

<p>ところが、実はAndroidアプリ開発では頻繁に遭遇するあのパターンが、<code>Promise</code>を使うと非常に取り回しが良くなりますので、紹介したいと思います。</p>

<!--more-->


<p>それは、<code>Intent</code>で外部<code>Activity</code>から何かしらの値を取得し、<code>onActivityResult</code>でその値を受け取るパターンです。</p>

<p><a href="https://developer.android.com/intl/ja/reference/android/content/Intent.html">Intent | Android Developers</a></p>

<p><a href="http://developer.android.com/intl/ja/reference/android/app/Activity.html#onActivityResult(int,%20int,%20android.content.Intent">Activity#onActivityResult | Android Developers</a></p>

<p>Androidでは、アプリ外部との連携を<code>Intent</code>という仕組みを使って制御しています。</p>

<p>取得したい情報や実行したい処理(Action)を<code>Intent</code>にセットし、<code>startActivityForResult</code>メソッドに渡すことで、外部アプリなどを起動し必要なデータを取得させたうえで、自分のアプリに返ってくる（<code>onActivityResult</code>メソッドが呼ばれ、引数にデータが渡される)ことが出来ます。</p>

<p>この<code>Intent</code>は大変便利な仕組みですが、その一方で<strong><em>一連のパイプラインの記述が<code>startActivityForResult</code>と<code>onActivityResult</code>の間で分断されてしまい、データの流れが追いにくい</em></strong>コードになっています。</p>

<p>例えば以下のような、ボタンをクリックすると外部アプリで写真を選択させて、自アプリに表示するだけのアプリについて考えてみましょう。</p>

<table>
<thead>
<tr>
<th style="text-align:center;"> ~<code>startActivityForResult</code> </th>
<th style="text-align:center;"> <code>onActivityResult</code> ~ </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center;"> <img src="/images/20151215/app-1-small.png" width="300" height="300"> </td>
<td style="text-align:center;"> <img src="/images/20151215/app-2-small.png" width="300" height="300"> </td>
</tr>
</tbody>
</table>


<pre><code class="scala Promise無しの例(パイプラインが分断される)">class MyActivity extends Activity with TypedFindView{
lazy val IMAGE_FETCH_ID = 12345

override def onCreate(bundle: Bundle) {
   //Activity初期化処理など
   //...
   findView(TR.button_image).onClick{
     _ =&gt;
      val intent = new Intent(Intent.ACTION_PICK, MediaStore.Images.Media.EXTERNAL_CONTENT_URI)
      intent.setType("image/*")
      startActivityForResult(intent, IMAGE_FETCH_ID)
      //データパイプラインがここで分断
    }
 }

 override def onActivityResult(requestCode: Int, resultCode: Int, data: Intent): Unit = {
  requestCode match {
    case IMAGE_FETCH_ID =&gt;
    //データパイプラインがここから継続
    if (resultCode == Activity.RESULT_OK)
      findView(TR.image).setImageURI(data.getData)
     else{
       //failed. Do something if needed.  
     }
    case _ =&gt; //do nothing
  }
}
}
</code></pre>

<p>これを<code>Promise</code>を使って書き換えてみましょう。</p>

<p><strong><code>Promise</code>によって、<code>startActivityForResult</code>から <code>onActivityResult</code>までの流れを、単一<code>Future</code>インスタンスの中に閉じ込めたかのように扱うことが出来ます。</strong></p>

<p>これでパイプラインの記述をスッキリ書くことが出来るようになりました。</p>

<pre><code class="scala Promise有りの例">class MainActivity extends Activity with TypedFindView with ImageLoadable{
lazy val uiContext = UIContext(this)
 override def onCreate(bundle: Bundle) {
   //Activity初期化処理など
   //...

   //データパイプラインを分断させず、そのまま記述できる
   findView(TR.button_image).onClick{
    _ =&gt; chooseImageUri().foreach{
      bmp =&gt; findView(TR.image).setImageURI(bmp)
    }(uiContext)
   }
 }
}
</code></pre>

<pre><code class="scala">trait ImageLoadable extends Activity {
  lazy val IMAGE_FETCH_ID = 12345
  private var promise: Option[Promise[Uri]] = None

  def chooseImageUri(): Future[Uri] = {
    promise.filterNot(_.isCompleted).foreach(_.failure(new InterruptedException("Asked to load another image. Aborted.")))
    val p = Promise[Uri]()
    promise = Some(p)
    val intent = new Intent(Intent.ACTION_PICK, MediaStore.Images.Media.EXTERNAL_CONTENT_URI)
    intent.setType("image/*")
    startActivityForResult(intent, IMAGE_FETCH_ID)
    p.future
  }

  override def onActivityResult(requestCode: Int, resultCode: Int, data: Intent): Unit = {
    super.onActivityResult(requestCode,resultCode,data)
    requestCode match {
      case IMAGE_FETCH_ID =&gt; if (resultCode == Activity.RESULT_OK)
        promise.foreach(_.success(data.getData))
      else
        promise.foreach(_.failure(ImageNotAvailableException("Failed to fetch image.")))
      case _ =&gt; //do nothing
    }
  }
}
</code></pre>

<p>ビルド可能なサンプルソースコードはこちらです。</p>

<p><a href="https://github.com/taisukeoe/ScalaPromiseDemo">taisukeoe/ScalaPromiseDemo</a></p>

<p>この例と似た、より一般的な例が以下の<code>Promise</code>を使ったCallback APIの<code>Future</code>化です。
しかしCallback APIの<code>Future</code>化は<code>scalaz.concurrent.Task.async</code>でも実現できますが、上記の例は実現できません（<code>onActivityResult</code>のせい）。</p>

<p><a href="https://github.com/taisukeoe/ScalaFPEvent/blob/aa6f784353e8e9147fd47ff6303407bd6faf345c/src/main/scala/ScalaStdFutureExample.scala">ScalaFPEvent - ScalaStdFutureExmaple</a></p>

<p><code>Promise</code>って意外と使えるジャン、と思ってもらえれば幸いです。</p>

<p>それでは。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Implicitには型注釈をつけましょう]]></title>
    <link href="http://taisukeoe.github.io/blog/2015/07/11/scala-implicits/"/>
    <updated>2015-07-11T22:52:58+09:00</updated>
    <id>http://taisukeoe.github.io/blog/2015/07/11/scala-implicits</id>
    <content type="html"><![CDATA[<p>Scalaには(とても今更ですが) Implicit/暗黙 というキーワードがあります。Implicitキーワードを宣言する場所をざっくり分けると、以下の4つ。</p>

<p>1) implicit class &hellip;</p>

<p>2) implicit parameter (e.g. (implicit a:A) )</p>

<p>3) implicit def &hellip;</p>

<p>4) implicit (var | val) &hellip;</p>

<p>この中で1,2は(明示的に)型を書かざるを得ませんが、3のdefの戻り値、及び4については、型注釈を明示的に書かずに型推論を働かせることが(少なくとも最新の2.11.7でも)可能です。</p>

<p>しかし型注釈を書かなかった場合、<strong>以下のような（一見理由の分かりにくい）コンパイルエラーに遭遇する可能性が有る</strong>ことはご存知でしょうか？</p>

<!--more-->


<pre><code class="scala">//compile success in declaring A, then B
scala&gt; :paste
object A {implicit val a = 1}
object B {import A._;implicitly[Int]}

//compile success in annotating type of A.a
scala&gt; :paste
object B {import A._ ; implicitly[Int]}
object A {implicit val a:Int = 1}

//COMPILE ERROR in declaring B, then A without type annotation
scala&gt; :paste
object B {import A._ ; implicitly[Int]}
object A {implicit val a = 1}
</code></pre>

<p>JIRAにも同種のissueが多数報告されています。</p>

<ul>
<li><p><a href="https://issues.scala-lang.org/browse/SI-9130">[SI-9130] destructuring binds, implicit resolution, and declaration order - Scala</a></p></li>
<li><p><a href="https://issues.scala-lang.org/browse/SI-5265">[SI-5265] warn on implicit def without explicit result type - Scala</a></p></li>
<li><p><a href="https://issues.scala-lang.org/browse/SI-5348">[SI-5348] Type errors overriding implicit vals - Scala</a></p></li>
</ul>


<p>この問題を防ぐために、コンパイラチームは<strong>暗黙の値やメソッドに型注釈をつけることを強く推奨</strong>しています。</p>

<blockquote><p>Implicits must be explicitly type annotated, otherwise the typechecker may ignore them from preceding parts of the same source file. This is done to avoid triggering spurious cycles in type inference.</p>

<p>暗黙(の値及びメソッド)には明示的に型注釈がつける必要があります。もし型注釈がないと、同じソースファイル上の前方から後方に向かって暗黙を参照している際に、型チェッカーが見落としてしまう恐れがあります。これは型推論をする際に、間違ったサイク
ルを引き起こさないために行っています。</p>

<ul>
<li>Comment by Jason Zaugg on <a href="https://issues.scala-lang.org/browse/SI-9130?focusedCommentId=71712&amp;page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-71712">SI-9130</a></li>
</ul>
</blockquote>

<p>というわけで、<strong>Implicitsには必ず型注釈をつけましょう！</strong></p>

<p>繰り返し<a href="https://gitter.im/scalajp/public">scalajp/public</a>で話題になるし、gitterのログ遡るのつらいしで記事にしてみました(`・ω・&#8217;)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ScalikeJDBC on Android SQLite]]></title>
    <link href="http://taisukeoe.github.io/blog/2015/05/06/scalikejdbc-on-android-sqlite/"/>
    <updated>2015-05-06T21:40:25+09:00</updated>
    <id>http://taisukeoe.github.io/blog/2015/05/06/scalikejdbc-on-android-sqlite</id>
    <content type="html"><![CDATA[<p>意外にもまだ試している人がいなさそうなので、<a href="https://rpscala.doorkeeper.jp/events/23383">rpscala合宿</a>でDEMOを作成した。</p>

<p><a href="https://github.com/taisukeoe/scalikejdbc-on-android">scalikejdbc-on-android</a></p>

<p><img src="/images/20150506/scalikejdbc_demo.png"></p>

<!--more-->


<h3>使用versionなど:</h3>

<ul>
<li>Scala 2.11.6</li>
<li>sbt 0.13.8</li>
<li>Target: Android 5.1</li>
<li>MinSDK: Android 4.0.3</li>
<li>pfn/android-sdk-plugin 1.3.22</li>
<li>ScalikeJDBC 2.2.6</li>
<li>SQLDroid 1.0.3</li>
</ul>


<h2>Android in ScalaのDBアクセス事情</h2>

<ul>
<li>自分は普段Android Database API + <a href="https://github.com/pocorall/scaloid/blob/060fd9b5d330d735be96ac0b9489b4600a6dec09/scaloid-common/src/main/st/org/scaloid/common/implicits.scala#L110-L120">RichCursor</a>を使う</li>
<li><a href="https://www.typesafe.com/activator/template/agile-scala-android-example">Slickを使用したTypesafe activatorテンプレート</a>などもある</li>
<li>そもそもDBをローカルに持つ必要のない（DBサーバー+クライアントキャッシュな)Androidアプリも多い</li>
</ul>


<h2><a href="http://scalikejdbc.org/">ScalikeJDBC</a>とは？</h2>

<p><code>a tidy SQL-based access library for Scala Developers</code>(公式ドキュメントより抜粋)</p>

<p>SQL文をそのまま(より型安全な方法で）扱えるのが特長。Androidでいえば<a href="http://developer.android.com/intl/ja/reference/android/database/sqlite/SQLiteDatabase.html">SQLiteDatabase.rawQuery</a>を好んで使う人向け。</p>

<h2>SQLite JDBC Driver</h2>

<p>今回はAndroidのSQLiteを使用するので、SQLite3に対応していることが必須。あとはPure Java実装か、Android NDKでAndroid用のNative Libraryを生成できる必要がある。</p>

<h3><a href="https://github.com/SQLDroid/SQLDroid">SQLDroid</a></h3>

<p>今回使用した、Android Database APIをラップしたJDBC Driver。ただあまり活発にメンテされていないようなので、プロダクションで使用するのは躊躇する。</p>

<h3><a href="http://docs.oracle.com/cd/E17076_02/html/installation/build_android_jdbc.html">Android JDBC Driver (Oracle)</a></h3>

<p>Android NDKを使用しビルドすることで、Android用のNative Library(.so)を生成できる…が、unmanagedDependenciesとして追加する必要があるので、ちょっと扱いずらい。（なお、<a href="http://d.hatena.ne.jp/esmasui/20120918/1347985333">この記事</a>を読む限り、Natvie Libraryを含めなくても動作する（＝Pure Java実装に自動的に切り替わっている？）模様。)</p>

<h3><a href="https://bitbucket.org/xerial/sqlite-jdbc">xerial/sqlite-jdbc</a></h3>

<p>現在Androidはサポートされておらず、実行すると</p>

<blockquote><p>java.lang.UnsatisfiedLinkError: dalvik.system.PathClassLoader[DexPathList[[zip file &ldquo;/system/framework/android.test.runner.jar&rdquo;, zip file &ldquo;/data/app/taisukeoe.scalikeroid-1/base.apk&rdquo;],nativeLibraryDirectories=[/vendor/lib, /system/lib]]] couldn&rsquo;t find &ldquo;libsqlitejdbc.so&rdquo;</p></blockquote>

<p>というRuntimeエラーとともに落ちる。</p>

<p><a href="https://bitbucket.org/xerial/sqlite-jdbc/issue/159/javafx-android-port-crashes-and-fails-to">Pure Java実装に切り替えるAPI</a>のfeatureリクエストは上がっているようなので、これが実装されれば使えるはず。</p>

<h2>落とし穴|Pitfalls</h2>

<h3><a href="https://www.sqlite.org/datatype3.html">SQLite</a>起因のもの</h3>

<ul>
<li><code>serial</code>データ型が存在しないので、<code>integer autoincrement</code>にする。</li>
<li><code>timestmap</code>および<code>datetime</code>データ型が存在せず、<code>timestamp</code>指定すると<code>yyyy-MM-dd hh:mm:ss</code>というISO8601フォーマットのTEXT型で保存されるため、WrappedResultSet.jodaDateTimeでDateTime型の値を抽出できない。<code>integer</code>型にしておいてWrappedResultSet.timestampを使う。</li>
</ul>


<h3>Android起因のもの</h3>

<ul>
<li><code>DatabseUtils.createDbFromSqlStatements</code>から手動でDatabaseを作成する必要がある</li>
</ul>


<h3>Android in Scala起因のもの</h3>

<ul>
<li><a href="https://github.com/pfn/android-sdk-plugin">pfn/android-sdk-plugin</a>のProguard後のclassファイルのキャッシュが重複してしまうことにより、ビルド時に以下のExceptionが投げられる</li>
</ul>


<blockquote><p>java.lang.IllegalArgumentException: already added: Lscala/util/parsing/combinator/JavaTokenParsers$class;</p></blockquote>

<p>これを防ぐために、sbtビルド定義に以下を追加する。</p>

<p><code>proguardCache in Android += ProguardCache("parser-combinators") % "org.scala-lang.modules" %% "scala-parser-combinators"</code></p>

<h2>雑感</h2>

<p>ハッカソンではDEMOまでしか作成できなかったが</p>

<ul>
<li>ScalikeJDBCの主だった機能は一通り試したい</li>
<li><a href="http://www.h2database.com/html/tutorial.html#android">h2 database</a>は公式でAndroid対応のJDBC driverを配布しているようなので、h2でも試したい</li>
<li>Typesafe activator templateにしたい</li>
</ul>

]]></content>
  </entry>
  
</feed>
